# 哈希表

哈希表就是一种离散表。输入通过哈希函数后生成唯一的答案，这个答案为输入的映射也就是输入在表中的位置，下次再找输入时，就可以通过哈希函数瞬间找到需要值的位置。

代码实现方法有：1.数组 2.set 3.map

主要用途：**一般哈希表都是用来快速判断一个元素是否出现集合里**

数组实现例题：leetconde242

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1: 输入: s = "anagram", t = "nagaram" 输出: true

示例 2: 输入: s = "rat", t = "car" 输出: false



思路：1.因为字符a到字符z的ASCII也是26个连续的数值，设置一个素组从0-25分别映射a-z；Yu[26]

​            2.Yu[s[i]-'a']可以对于映射位置。

​            先对数组s中对于映射位置++；而后对数组t映射位置--;

​             3.最后数组Yu[26]中元素不都为0则返回false，否则返回ture；

代码如下：

```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        int record[26] = {0};
        for (int i = 0; i < s.size(); i++) {
            // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了
            record[s[i] - 'a']++;
        }
        for (int i = 0; i < t.size(); i++) {
            record[t[i] - 'a']--;
        }
        for (int i = 0; i < 26; i++) {
            if (record[i] != 0) {
                // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。
                return false;
            }
        }
        // record数组所有元素都为零0，说明字符串s和t是字母异位词
        return true;
    }
};
```

set结构分为：set 、unordered_set、muliset

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。

应用场景：当需要的key很多时，或者区间很大时，数组哈希需要大量的空间。

题目：leetcode349

题意：给定两个数组，编写一个函数来计算它们的交集。

![](asset\20200818193523911.png)

**说明：** 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。

解题思路：1.将nums1放入unordered_set中

​                    2.用find函数遍历nums2，当不在unordered_set中时会等于unordered_set.end()

代码如下：

```cpp
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> result_set; // 存放结果，之所以用set是为了给结果集去重
        unordered_set<int> nums_set(nums1.begin(), nums1.end());
        for (int num : nums2) {
            // 发现nums2的元素 在nums_set里又出现过
            if (nums_set.find(num) != nums_set.end()) {
                result_set.insert(num);
            }
        }
        return vector<int>(result_set.begin(), result_set.end());
    }
};
```

for循环的用法。